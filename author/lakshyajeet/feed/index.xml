<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>lakshyajeet &#8211; Lakshyajeet&#039;s Blog</title>
	<atom:link href="/author/lakshyajeet/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Fri, 14 Mar 2025 15:03:40 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.8.1</generator>

<image>
	<url>/wp-content/uploads/2025/01/cropped-nyan-1-32x32.gif</url>
	<title>lakshyajeet &#8211; Lakshyajeet&#039;s Blog</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>User Roles in WordPress</title>
		<link>/user-roles-in-wordpress/</link>
					<comments>/user-roles-in-wordpress/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Fri, 14 Mar 2025 15:03:40 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[theme development]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wordpress theme]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=612</guid>

					<description><![CDATA[When working with WordPress, user roles play a vital role in determining who can access specific parts of the website, and what actions they can perform. For many WordPress administrators, its crucial to define granular access levels based on the types of content being managed on the site. Whether we are managing blog posts, products [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>When working with WordPress, user roles play a vital role in determining who can access specific parts of the website, and what actions they can perform. For many WordPress administrators, its crucial to define granular access levels based on the types of content being managed on the site. Whether we are managing blog posts, products or events, its important to customize the roles and capabilities to ensure that the right people have access to the right tools. In this post, weâ€™ll explore how to set up custom user roles for custom post types and taxonomies in WordPress, with a focus on managing events.</p>



<h2 class="wp-block-heading">Setting Up Custom Post Types and Taxonomies</h2>



<p>Let&#8217;s assume we already have a CPT, <strong>Event</strong> setup with its taxonomy, <strong>Event Type</strong>.</p>



<pre class="wp-block-syntaxhighlighter-code">function register() {
    register_post_type(
        'my_event', array(
        //..
        'capability_type' =&gt; array('event', 'events'),  // Define custom capabilities
        'map_meta_cap' =&gt; true,  // Use meta capabilities
    );
    register_taxonomy(
        'event-type',
        'my_event',
        //..
        'capabilities' =&gt; array(  // Define custom capabilities
                'manage_terms' =&gt; 'manage_event_types',
                'edit_terms' =&gt; 'edit_event_types',
                'delete_terms' =&gt; 'delete_event_types',
                'assign_terms' =&gt; 'assign_event_types',
            )
    );
}
add_action('init', 'register');</pre>



<h2 class="wp-block-heading"><strong>Customizing User Roles and Permissions</strong></h2>



<p>Now that we have our custom post types and taxonomies, the next step is to define custom user roles that can manage these types. WordPress comes with default roles, but we can create a new role (<strong>Event Manager</strong>) with specific permissions related to our custom post types.</p>



<pre class="wp-block-syntaxhighlighter-code">function get_all_event_caps() {
    $capabilities = array();
    $post_types = array('my_event');

    foreach($post_types as $post_type) {
        $post_type_object = get_post_type_object($post_type);

        // Check if the post type object is valid.
        if (! $post_type_object instanceof WP_Post_Type) {
            continue;
        }

        // Remove default post capabilities.
        $post_type_caps = (array) $post_type_object-&gt;cap;  // Get capabilities for the post type

        // Remove default post capabilities
        unset($post_type_caps['edit_post']);
        unset($post_type_caps['read_post']);
        unset($post_type_caps['delete_post']);
        unset($post_type_caps['create_posts']);

        $capabilities = array_merge($capabilities, array_values($post_type_caps));   
    }

    $taxonomies = array('event-type');

    foreach($taxonomies as $taxonomy) {
        $taxonomy_object = get_taxonomy($taxonomy);

        // Check if the taxonomy object is valid.
        if (! $taxonomy_object instanceof WP_Taxonomy) {
            continue;
        }

        $taxonomy_caps = (array) $taxonomy_object-&gt;cap;
        $capabilities = array_merge($capabilities, array_values($taxonomy_caps)); 
    }

    return $capabilities;
}</pre>



<p>Before assigning the permission we make a helper function to help us get all the permissions required for the Event Manager.</p>



<pre class="wp-block-syntaxhighlighter-code">function event_add_roles() {
    $capabilities = get_all_event_caps();
    
    // Add each capability to the 'administrator' role.
    $admin_role = get_role('administrator');

    foreach($capabilities as $capability) {
        $admin_role-&gt;add_cap($capability);
    }

    $capabilities = array_fill_keys($capabilities, true);

    add_role('event-manager', 'Event Manager', $capabilities);
}
add_action('init', 'event_add_roles');

function event_remove_roles() {
    $capabilities = get_all_event_caps();
    $admin_role = get_role('administrator');

    foreach($capabilities as $capability) {
        $admin_role-&gt;remove_cap($capability);
    }
    
    // Remove the 'Event Manager' role.
    remove_role('event-manager');
}</pre>



<ul class="wp-block-list">
<li><strong><code>get_all_event_caps()</code></strong>: This function retrieves all the necessary capabilities for our custom post types and taxonomies. </li>



<li><strong><code>event_add_roles()</code></strong>: This creates a custom role called &#8220;Event Manager&#8221; and assigns it the necessary capabilities for managing events and event types. </li>



<li><strong><code>event_remove_roles()</code></strong>: This function removes the custom &#8220;Event Manager&#8221; role and its capabilities.</li>
</ul>



<h2 class="wp-block-heading">Conclusion</h2>



<p>Custom user roles in WordPress help maintain a secure and efficient management system, especially when dealing with multiple types of content. By defining custom post types and taxonomies along with appropriate capabilities, we can ensure that users have the right level of access based on their specific role, this approach provides the flexibility to keep our WordPress site organized and secure.</p>
]]></content:encoded>
					
					<wfw:commentRss>/user-roles-in-wordpress/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Rewrite API: A practical usecase</title>
		<link>/rewrite-api-a-practical-usecase/</link>
					<comments>/rewrite-api-a-practical-usecase/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Thu, 13 Mar 2025 17:09:51 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[theme development]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wordpress theme]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=602</guid>

					<description><![CDATA[As we know, the Rewrite API in WordPress, allows us to control the structure and handling of URLs for our content. Whether we want to create custom URLs for our post types, taxonomies, or even specific pages, this API comes in handy. In this blog post, we will walk through how to leverage the Rewrite [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>As we know, the Rewrite API in WordPress, allows us to control the structure and handling of URLs for our content. Whether we want to create custom URLs for our post types, taxonomies, or even specific pages, this API comes in handy. In this blog post, we will walk through how to leverage the Rewrite API to create custom permalink structures for a custom post type and its taxonomy.</p>



<h2 class="wp-block-heading">Adding Custom Rewrite Rules</h2>



<p>We have a custom post type called <code>my_event</code>, which is used to represent different events. We also have a custom taxonomy called <code>event_type</code> that categorizes the events. We will set up custom permalinks to display events in a structured format, including both the event type and a unique identifier for the event.</p>



<p>First, we need to tell WordPress how to interpret custom URLs for our events. In the code snippet below, we define a custom rewrite rule that includes both the event type and a unique event identifier in the URL.</p>



<pre class="wp-block-syntaxhighlighter-code">function event_rewrite_rule() {
    // Add rewrite tag for event type.
    add_rewrite_tag('%event_type%', '([^&amp;]+)', 'event_type=');

    // Add custom rewrite rule.
    add_rewrite_rule(
        '^event/([^/]+)/([^/]+)-([0-9]+)/?',
        'index.php?event_type=$matches[1]&amp;post_type=my_event&amp;name=$matches[2]&amp;p=$matches[3]',
        'top'
    );
}

add_action('init', 'event_rewrite_rule');</pre>



<h2 class="wp-block-heading">Customizing Permalink Structure for Events</h2>



<p>We need to customize the permalink structure for the <code>my_event</code> post type to include both the event type and the event ID.</p>



<pre class="wp-block-syntaxhighlighter-code">function custom_event_permalink() {
    global $wp_rewrite;

    $args = $wp_rewrite-&gt;extra_permastructs['my_event'];

    // Remove the default permalink structure
    remove_permastruct('my_event');
    unset($args['struct']);

    $args['with_front'] = false;

    // Define the new permalink structure.
    add_permastruct('my_event', 'event/%event_type%/%my_event%-%post_id%', $args);
}

add_action('init', 'custom_event_permalink', 11); // 11 ensures this runs after other rules.</pre>



<h2 class="wp-block-heading">Modifying Permalink for Each Event</h2>



<p>To ensure that each event&#8217;s permalink reflects its event type, we need to modify the URL generation process for individual events.</p>



<pre class="wp-block-syntaxhighlighter-code">function event_permalink($permalink, $post) {
    if ('my_event' !== $post-&gt;post_type) {
        return $permalink;
    }

    $type = wp_get_object_terms($post-&gt;ID, 'event-type');

    $type = wp_list_sort($type, array('term_id' =&gt; 'ASC'));

    if (!is_wp_error($type) &amp;&amp; !empty($type) &amp;&amp; is_object($type[0])) {
        $type_slug = $type[0]-&gt;slug;
    } else {
        $type_slug = 'hello'; // Default slug if no event type is found.
    }

    // Replace placeholders with values.
    $permalink = str_replace(
        ['%event_type%', '%post_id%'],
        [$type_slug, $post-&gt;ID],
        $permalink
    );

    return $permalink;
}
add_filter('post_type_link', 'event_permalink', 10, 2);</pre>



<h2 class="wp-block-heading">Filtering Events by Event Type</h2>



<p>Finally, we want to make sure that WordPress can filter events by the <code>event_type</code> taxonomy on the front end and in the admin panel. This will allow for custom filtering based on the event type slug in the URL.</p>



<pre class="wp-block-syntaxhighlighter-code">function add_event_type_query_var($vars) {
    $vars[] = 'event_type';
    return $vars;
}

add_filter('query_vars', 'add_event_type_query_var');

function filter_events_by_event_type($query) {
    if (is_admin() &amp;&amp; !$query-&gt;is_main_query()) {
        return;
    }

    $event_type = get_query_var('event_type');
    if (!empty($event_type)) {
        $tax_query = $query-&gt;get('tax_query');
        if (!is_array($tax_query)) {
            $tax_query = array();
        }
        $tax_query['relation'] = 'AND';
        $tax_query[] = array(
            'taxonomy' =&gt; 'event-type',
            'field' =&gt; 'slug',
            'terms' =&gt; $event_type,
        );
        $query-&gt;set('tax_query', $tax_query);
    }
}

add_action('pre_get_posts', 'filter_events_by_event_type');</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>With this, using the WordPress Rewrite API, we have successfully created a custom URL structure for our <code>my_event</code> post type and filtered events based on their <code>event_type</code> taxonomy. This provides a clean, SEO-friendly URL structure for our custom events and ensures the filtering works seamlessly on both the front end and back end.</p>
]]></content:encoded>
					
					<wfw:commentRss>/rewrite-api-a-practical-usecase/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Introduction to WordPress Rewrite API</title>
		<link>/introduction-to-wordpress-rewrite-api/</link>
					<comments>/introduction-to-wordpress-rewrite-api/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Wed, 12 Mar 2025 16:11:27 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[theme development]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wordpress theme]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=592</guid>

					<description><![CDATA[The Rewrite API is a method to help developer manipulate URL structures also known as permalinks for custom post types, taxonomies. It is a critical component of WordPress and used extensively to create user-friendly and SEO-Optimized permalinks. How Rewrite API works? The Rewrite API allows developers to add their own rewrite rules and tie them [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>The Rewrite API is a method to help developer manipulate URL structures also known as permalinks for custom post types, taxonomies. It is a critical component of WordPress and used extensively to create user-friendly and SEO-Optimized permalinks.</p>



<h2 class="wp-block-heading">How Rewrite API works?</h2>



<p>The Rewrite API allows developers to add their own rewrite rules and tie them to a specific query variables. When a user visits a URL, WordPress looks through these rewrite rules to determine which content to display, based on the matched pattern.</p>



<p><strong>Rewrite Rules</strong>: These are patterns that define the URL structure for our content. They are added through the <code>add_rewrite_rule()</code> function. </p>



<p><strong>Query Vars</strong>: Query variables are part of the URL, typically in the form of key-value pairs, used to retrieve specific content. Developers can define custom query variables using <code>add_rewrite_tag()</code>. </p>



<p><strong>Flush Rewrite Rules</strong>: After making changes to rewrite rules, we need to flush them to apply the new settings. This is done through the <code>flush_rewrite_rules()</code> function.</p>



<h2 class="wp-block-heading">Using Rewrite API</h2>



<h3 class="wp-block-heading">Creating Custom Permalinks for CPT</h3>



<p>It is one of the most common use case of Rewrite API. When registering a CPT we can use the <code>rewrite</code> parameter to add rewrite rules.</p>



<pre class="wp-block-syntaxhighlighter-code">function my_custom_post_type() {
    $args = array(
        'public' =&gt; true,
        'rewrite' =&gt; array('slug' =&gt; 'my-custom-posts'),
        'label'  =&gt; 'Custom Posts'
    );
    register_post_type('custom_post', $args);
}
add_action('init', 'my_custom_post_type');</pre>



<p>Similarly for Custom Taxonomies we can use:</p>



<pre class="wp-block-syntaxhighlighter-code">function my_custom_post_type() {
    $args = array(
        'public' =&gt; true,
        'rewrite' =&gt; array('slug' =&gt; 'my-custom-posts'),
        'label'  =&gt; 'Custom Posts'
    );
    register_post_type('custom_post', $args);
}
add_action('init', 'my_custom_post_type');</pre>



<h2 class="wp-block-heading">Redirecting URLs</h2>



<p>Another practical application of the Rewrite API is for handling redirects. For example, if we need to redirect URLs  we can use the <code>add_rewrite_rule()</code> function to create redirects.</p>



<pre class="wp-block-syntaxhighlighter-code">function custom_redirect() {
    add_rewrite_rule('^old-page/?$', 'index.php?pagename=new-page', 'top');
}
add_action('init', 'custom_redirect');</pre>



<h2 class="wp-block-heading">Adding Custom Query Variables</h2>



<p>We might need custom query variables to handle specific requests from our URL. With the Rewrite API, we can define these variables using <code>add_rewrite_tag()</code>.</p>



<pre class="wp-block-syntaxhighlighter-code">function add_custom_query_var($vars) {
    $vars[] = 'my_custom_var';
    return $vars;
}
add_filter('query_vars', 'add_custom_query_var');</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>The Rewrite API in WordPress is an essential tool for developers looking to create custom URL structures, improve SEO, and redirect users from outdated content. By understanding how to utilize the Rewrite API, we gain full control over how WordPress handles permalinks, allowing us to customize our website.</p>
]]></content:encoded>
					
					<wfw:commentRss>/introduction-to-wordpress-rewrite-api/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Dashboard Widgets in WordPress</title>
		<link>/dashboard-widgets-in-wordpress/</link>
					<comments>/dashboard-widgets-in-wordpress/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Tue, 11 Mar 2025 15:20:19 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[theme development]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wordpress theme]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=582</guid>

					<description><![CDATA[As WordPress developers we know how powerful and flexible it is, one of the feature that allows us to streamline our workflows and improve user experience is the WordPress dashboard. By customizing the dashboard with widgets we can have users have quick access to various information and tasks. What are Dashboard Widgets? Dashboard widgets are [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>As WordPress developers we know how powerful and flexible it is, one of the feature that allows us to streamline our workflows and improve user experience is the WordPress dashboard. By customizing the dashboard with widgets we can have users have quick access to various information and tasks. </p>



<h2 class="wp-block-heading">What are Dashboard Widgets?</h2>



<p>Dashboard widgets are small, customizable modules that appear on the WordPress admin screen. These widgets provide essential information about the various aspects of the site. The default WordPress dashboard comes with several built-in widgets, such as &#8220;At a Glance,&#8221; &#8220;Recent Drafts,&#8221; and &#8220;Quick Draft,&#8221; but as WordPress users, we can also add custom widgets to suit our needs.</p>



<h2 class="wp-block-heading">How to Add Custom Widgets to Your WordPress Dashboard</h2>



<p>Inside our plugin we can add Custom Dashboard widgets using the <code>wp_add_dashboard_widget()</code> </p>



<pre class="wp-block-syntaxhighlighter-code">function custom_dashboard_widget() {
    wp_add_dashboard_widget(
        'custom_dashboard_widget', // Widget slug
        'My Custom Widget',        // Widget title
        'custom_dashboard_widget_html' // Function to display widget
    );
}

function custom_dashboard_widget_html() {
    echo '&lt;p&gt;This is a custom dashboard widget&lt;/p&gt;';
}

add_action('wp_dashboard_setup', 'custom_dashboard_widget');</pre>



<p>The <code>wp_add_dashboard_widget()</code> function takes in a <strong>widget slug</strong>, <strong>title</strong>, and a <strong>callback function</strong> to display the widget.</p>



<p>Similar to this we can add more advanced features to it as well.</p>



<p>Exampleâ€” &#8220;Widget for fetching the latest posts from a blog.&#8221;</p>



<pre class="wp-block-syntaxhighlighter-code">function latest_posts_dashboard_widget() {
    wp_add_dashboard_widget(
        'latest_posts_dashboard_widget',
        'Latest Posts',                  
        'latest_post_dashboard_widget_html'
    );
}

function latest_post_dashboard_widget_html() {
    $args = array(
        'posts_per_page' =&gt; 5,
        'post_status'    =&gt; 'publish',
        'order'           =&gt; 'DESC',
        'orderby'         =&gt; 'date',
    );
    
    $query = new WP_Query($args);

    if ($query-&gt;have_posts()) {
        echo '&lt;ul&gt;';
        
        while ($query-&gt;have_posts()) {
            $query-&gt;the_post();
            echo '&lt;li&gt;&lt;a href="' . get_permalink() . '"&gt;' . get_the_title() . '&lt;/a&gt;&lt;/li&gt;';
        }
        
        echo '&lt;/ul&gt;';
    } else {
        echo '&lt;p&gt;No recent posts found.&lt;/p&gt;';
    }
    
    wp_reset_postdata();
}

add_action('wp_dashboard_setup', 'latest_posts_dashboard_widget');</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>Dashboard Widgets are one of the simplest and powerful way to customize and enhance the WP Admin interface. They provide us with quick access to important information, boost our productivity, and help streamline our workflows. Whether we&#8217;re managing a personal blog, running an e-commerce store, or handling multiple client websites, taking full advantage of dashboard widgets can make our jobs much easier.</p>
]]></content:encoded>
					
					<wfw:commentRss>/dashboard-widgets-in-wordpress/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Working with Transient API</title>
		<link>/working-with-transient-api/</link>
					<comments>/working-with-transient-api/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Mon, 10 Mar 2025 14:33:27 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[plugin development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=572</guid>

					<description><![CDATA[As we have seen previously seen what the Transient API is in WordPress, this blog explores the best practices and other things to keep in mind when using the Transient API to ensure efficiency, integrity and speed of our website. Best Practices for Using Transient API Appropriate Expiration Time Transients are intended for temporary storage [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>As we have seen previously seen what the Transient API is in WordPress, this blog explores the best practices and other things to keep in mind when using the Transient API to ensure efficiency, integrity and speed of our website.</p>



<h2 class="wp-block-heading">Best Practices for Using Transient API</h2>



<h3 class="wp-block-heading"><strong>Appropriate Expiration Time</strong></h3>



<p>Transients are intended for temporary storage so its important to set correct expiration time based on how often the data changes. For example some event data might only change a few times a day so setting the transient to expire in an hour will be optimal. However if the expiration is too big the cached data may become stale.</p>



<h3 class="wp-block-heading"><strong>Delete Transients When Appropriate</strong></h3>



<p>Itâ€™s important to clear transients when data changes. We can use hooks to delete a transient when a new post/data modified. This ensures that the cache reflects the most current data.</p>



<h3 class="wp-block-heading"><strong>Store Only the Necessary Data</strong></h3>



<p>Transients should store only the data that is necessary for quick access. We usually store the post IDs, but if we needed additional data like custom fields, we could retrieve that data only when necessary, ensuring we don&#8217;t store excessive information in the cache.</p>



<h3 class="wp-block-heading"><strong>Using Transients for Expensive Operations</strong></h3>



<p>Use transients to cache results of expensive operations such as API calls, database queries, or other heavy computations. This reduces the need to repeat these operations on every page load and can significantly speed up our site.</p>



<h2 class="wp-block-heading">Example: Using Transient API for Displaying Latest Events</h2>



<pre class="wp-block-syntaxhighlighter-code">function latest_events_shortcode() {
    $args = array(
        'post_type' =&gt; 'my_event',
        'posts_per_page' =&gt; 5,
        'orderby' =&gt; 'DESC'
    );

    // Check if the transient already exists
    $latest = get_transient('latest_events');

    // If the transient doesnt exist query the database and set a new transient
    if ( ! $latest ) {
        // Query the posts
        $query = new WP_Query($args);

        $events = array();

        if ($query-&gt;have_posts()) {
            while ($query-&gt;have_posts()) {
                $query-&gt;the_post();
                $events[] = get_the_ID();
            }
            wp_reset_postdata();
        }

        set_transient('latest_events', $events, 1 * HOUR_IN_SECONDS);
        $latest = get_transient('latest_events');
    }
    ob_start();
    if ($latest) {
        foreach ($latest as $event) {
            echo '&lt;h2&gt;' . get_the_title($event) . '&lt;/h2&gt;';
        } 
    } else {
        echo 'No Events Found';
    }
    return ob_get_clean();
}
add_shortcode('latest', 'latest_events_shortcode');

// Clear the transient when new event is saved or updated
add_action('save_post_my_event', function () {
    delete_transient('latest_events');
});</pre>



<ol class="wp-block-list">
<li><strong>Checking the Transient</strong>: The function <code>get_transient('latest_events')</code> attempts to fetch the latest events from the cache.</li>



<li><strong>Querying the Database</strong>: If the transient doesn&#8217;t exist we run a query to fetch the latest events and store the results in a transient.</li>



<li><strong>Setting the Transient</strong>: We store the event IDs in the transient. </li>



<li><strong>Displaying the Events</strong>: If the transient exists, we loop through the event IDs and display the titles of the events.</li>



<li><strong>Cache Invalidation</strong>: The <code>delete_transient('latest_events')</code> action ensures that the cache is cleared when a new event is saved or an existing event is updated, so that the cache stays up to date.</li>
</ol>



<h2 class="wp-block-heading">Conclusion</h2>



<p>The WordPress Transient API is a simple yet powerful tool that can help us optimize the performance of our websites by caching expensive queries or external API calls. </p>



<p>By following best practices such asâ€” setting appropriate expiration times, deleting expired transients and storing only important information we can improve the user experience by delivering content faster while reducing the load on our servers.</p>



<p></p>
]]></content:encoded>
					
					<wfw:commentRss>/working-with-transient-api/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Transient API and HTTP API in WordPress</title>
		<link>/transient-api-and-http-api-in-wordpress/</link>
					<comments>/transient-api-and-http-api-in-wordpress/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Wed, 05 Mar 2025 14:14:42 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[theme development]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wordpress theme]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=561</guid>

					<description><![CDATA[As developers, we frequently find ourselves interacting with various APIs to streamline our workflows, enhance performance and improve the overall user experience. Two of the tools that help us achieve this are the HTTP API and the Transients API. In this blog we will explore both of these, as to how we can incorporate them [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>As developers, we frequently find ourselves interacting with various APIs to streamline our workflows, enhance performance and improve the overall user experience. Two of the tools that help us achieve this are the <strong>HTTP API</strong> and the <strong>Transients API</strong>. In this blog we will explore both of these, as to how we can incorporate them into our WordPress projects.</p>



<h2 class="wp-block-heading">The Transients API</h2>



<p>The Transients API allows us to store temporary data in the WordPress database with a fixed expiration time. This is perfect for data that doesnâ€™t change frequently like API responses, settings or query results. When we store data as a transient, WordPress automatically delete it once it expires, reducing the need for manual data clean up.</p>



<h3 class="wp-block-heading">Why Use Transients?</h3>



<p>The Transients API is an excellent tool for improving query performance by reducing the number of database queries or even the external API calls. By caching data that does not change often we can reduce server load and speed up the page loads, and improve the overall user experience.</p>



<p>Transients are especially useful for storing API responses, product listings, user preferences or <strong>any data that is expensive to fetch or compute but doesnâ€™t change frequently</strong>.</p>



<h3 class="wp-block-heading">Setting and Getting Transients</h3>



<p>To work with transients we have a few key functions which we can useâ€”</p>



<ul class="wp-block-list">
<li><code>set_transient( $transient, $value, $expiration )</code> â€“ Used to store data as a transient.</li>



<li><code>get_transient( $transient )</code> â€“ Retrieves the data stored in a transient.</li>



<li><code>delete_transient( $transient )</code> â€“ Deletes a specific transient.</li>
</ul>



<pre class="wp-block-syntaxhighlighter-code">// Store data in a transient
set_transient('my_transient', 'This is some data', 3600);

// Retrieve data from the transient
$stored_data = get_transient('my_transient');

if ($stored_data) {
    echo "Transient data: $stored_data";
} else {
    echo "No transient data found.";
}</pre>



<h2 class="wp-block-heading">The HTTP API</h2>



<p>The <strong>HTTP API</strong> in WordPress is a tool that simplifies making HTTP requests, such as GET, POST, PUT, and DELETE. When we need to fetch data from external sources or send data to external servers, the HTTP API is our go-to solution.</p>



<h3 class="wp-block-heading">GET with Transient Caching</h3>



<p>When working with external APIs we often face performance issues. Fetching data from remote servers can be slow and resource intensive, the problem becomes ever worse when the same data is being fetched repeatedly. This is where <strong>transient caching</strong> becomes invaluable.</p>



<p>The <strong>Transients API</strong> allows us to store data for a specific period reducing the need for repeated HTTP requests. By combining the HTTP API with transient caching we can ensure that our application only fetches data from external sources when necessary which in turn helps to reduce latency and minimize the load on servers.</p>



<pre class="wp-block-syntaxhighlighter-code">$transient_key = 'external_api_data';
$cached_data = get_transient($transient_key);

if (false === $cached_data) {
    // no cache is found so make the HTTP request
    $response = wp_remote_get('https://api.example.com/data');
    
    if (is_wp_error($response)) {
        $error = $response-&gt;get_error_message();
        echo "Something went wrong: $error";
    } else {
        // Cache the response
        $cached_data = wp_remote_retrieve_body($response);
        set_transient($transient_key, $cached_data, 12 * HOUR_IN_SECONDS);
        echo "Data fetched successfully: $cached_data";
    }
} else {
    // Use cached data
    echo "Using cached data: $cached_data";
}</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>The <strong>HTTP API</strong> and <strong>Transients API</strong> are two powerful tools that can help us build efficient and high performance WordPress applications. By understanding how to use them effectivelyâ€”whether its caching GET requests or storing temporary data we can create better sites and all while reducing server load.</p>
]]></content:encoded>
					
					<wfw:commentRss>/transient-api-and-http-api-in-wordpress/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Handling Media with REST API</title>
		<link>/handling-media-with-rest-api/</link>
					<comments>/handling-media-with-rest-api/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Tue, 04 Mar 2025 15:15:17 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[theme development]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wordpress theme]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=552</guid>

					<description><![CDATA[As we have seen previously how easy it is to create and interact with WordPress using its REST API. This blog will explore how to use this REST API to handle media on our site. Using Default REST API Route To upload an image using the default media route, we can use a POST request [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>As we have seen previously how easy it is to create and interact with WordPress using its REST API. This blog will explore how to use this REST API to handle media on our site.</p>



<h2 class="wp-block-heading"><strong>Using Default REST API Route</strong></h2>



<p>To upload an image using the default media route, we can use a <code>POST</code> request to the <code>/wp-json/wp/v2/media</code> endpoint.</p>



<pre class="wp-block-syntaxhighlighter-code">curl --user 'user:pass' -X POST http://wp.local/wp-json/wp/v2/media \
    -H "Content-Type: image/png" \
    -H "Content-Disposition: attachment; filename=\"filename.png\"" \
    --data-binary @filename.png
</pre>



<p>Upon successful upload WordPress will process the image store it in the media library, and return the media data in a JSON response, which includes the mediaâ€™s ID, URL, and other relevant metadata.</p>



<h2 class="wp-block-heading">Custom Media Upload Handler with REST API</h2>



<p>While WordPress provides a default endpoint for media uploads, its not uncommon to want to create a custom route for uploading media.</p>



<h3 class="wp-block-heading">Defining the Custom Route and Handler</h3>



<pre class="wp-block-syntaxhighlighter-code">function image_upload_route() {
    register_rest_route('my/v1', '/upload-image', [
        'methods' =&gt; 'POST',
        'callback' =&gt; 'handle_image_upload',
        'permission_callback' =&gt; '__return_true',
    ]);
}

add_action('rest_api_init', 'image_upload_route');

function handle_image_upload(WP_REST_Request $request) {
    if (empty($_FILES['file'])) {
        return new WP_REST_Response('No file uploaded', 400);
    }

    $file = $_FILES['file'];

    // Validate file type
    $allowed_mime_types = ['image/jpeg', 'image/png', 'image/gif'];
    if (!in_array($file['type'], $allowed_mime_types)) {
        return new WP_REST_Response('Invalid file type', 400);
    }

    include_once ABSPATH.'wp-admin/includes/file.php';
    $upload = wp_handle_upload($file, array( 'test_form' =&gt; false ));

    if (isset($upload['error'])) {
        return new WP_REST_Response($upload['error'], 500);
    }

    // Create attachment in WordPress media library
    $attachment = [
        'post_mime_type' =&gt; $file['type'],
        'post_title'     =&gt; sanitize_text_field($file['name']),
        'post_content'   =&gt; '',
        'post_status'    =&gt; 'inherit',
    ];

    $attachment_id = wp_insert_attachment($attachment, $upload['file']);

    // Get the URL of the uploaded file
    $attachment_url = wp_get_attachment_url($attachment_id);

    // Return the response with attachment data
    return new WP_REST_Response([
        'id' =&gt; $attachment_id,
        'url' =&gt; $attachment_url,
        'mime_type' =&gt; $file['type'],
        'name' =&gt; $file['name'],
    ], 200);
}</pre>



<ul class="wp-block-list">
<li><strong>Registering the Custom Route:</strong> We use <code>register_rest_route</code> to create a custom REST API route at <code>/wp-json/my/v1/upload-image</code>. This route is uses the <code>handle_image_upload()</code> function, which will handle the file upload logic.</li>



<li><strong>Callback Function:</strong> Inside the callback function, we first check whether a file has been uploaded. </li>



<li><strong>File Type Validation:</strong> We ensure that the uploaded file is one of the allowed image types (JPEG, PNG, or GIF). If the file type doesnt match we return an error message.</li>



<li><strong>Handling the Upload:</strong> Using WordPressâ€™s built-in <code>wp_handle_upload</code> function, we process the file. If the upload is successful, we move on to inserting it into the media library.</li>



<li><strong>Inserting into the Media Library:</strong> We use <code>wp_insert_attachment</code> to insert the uploaded file into WordPressâ€™s media library as an attachment. Then, we retrieve the URL of the uploaded file using <code>wp_get_attachment_url</code>.</li>



<li><strong>Returning the Response:</strong> Finally, we send a JSON response back to the client with the attachment ID, URL, MIME type, and file name.</li>
</ul>



<h3 class="wp-block-heading">Uploading the Image with <code>curl</code></h3>



<p>To upload an image using this custom handler we can again use <code>curl</code> but this time, we need to target the custom route (<code>/wp-json/my/v1/upload-image</code>).</p>



<pre class="wp-block-syntaxhighlighter-code">curl -X POST http://wp.local/wp-json/my/v1/upload-image -F "file=@filename.png"</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>In this post, we covered two ways of handling media uploads in WordPress using the REST API:</p>



<ol class="wp-block-list">
<li>Using WordPressâ€™s default media route to upload files.</li>



<li>Creating a custom media upload handler with our own logic.</li>
</ol>



<p>By leveraging the WordPress REST API, we can easily integrate media functionality into our applications giving us more control over how media files are handled and processed.</p>



<p></p>
]]></content:encoded>
					
					<wfw:commentRss>/handling-media-with-rest-api/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>WordPress REST API Internals</title>
		<link>/wordpress-rest-api-internals/</link>
					<comments>/wordpress-rest-api-internals/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Mon, 03 Mar 2025 16:00:02 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[plugin development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=536</guid>

					<description><![CDATA[When working with WordPress, REST API is one of the most powerful feature, whether building custom plugins, integrating external applications or simply extending the functionality of the site. This blog explores the internals how this works. The Request Flow The process begins as soon as a request is made to the WordPress siteâ€™s REST API [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>When working with WordPress, REST API is one of the most powerful feature, whether building custom plugins, integrating external applications or  simply extending the functionality of the site. This blog explores the internals how this works.</p>



<h2 class="wp-block-heading">The Request Flow</h2>



<p>The process begins as soon as a request is made to the WordPress siteâ€™s REST API endpoints.</p>



<p>A client(browser, app or server) makes a request to the server on the server&#8217;s REST URL.</p>



<p><code>parse_request</code> action the WordPress core routing system kicks into action. The <code>WP</code> class processes the incoming request and the <code>parse_request</code> action is triggered. This is where WordPress begins to understand that the request is for the REST API and determines the correct route.</p>



<p>The <code>rest_api_loaded()</code> function is the entry point for the REST API, it checks if the request is for the REST API by checking the <code>rest_route</code> query variable. If a valid route is found it defines the <code>REST_REQUEST</code> constant which tells WordPress that it should proceed with processing it as a REST API request.</p>



<p>WordPress calls the <code>rest_get_server()</code> function which returns an instance of the <code>WP_REST_Server</code> class. This class handles the core tasks of routing, authentication and response generation. There is also a function which allows developers to replace the default server class with a custom implementation using the <code>wp_rest_server_class</code> filter.</p>



<p>Now, the <code>rest_api_init</code> action is triggered. This is one of the most important hooks in the REST API. Itâ€™s the perfect place to register custom routes with <code>register_rest_route()</code> or create custom REST fields using <code>register_rest_field()</code> or perform any other setup.</p>



<p>The <code>WP_REST_Server</code>â€™s <code>serve_request()</code> method is the main component of the REST API request processing. It is here WordPress checks the userâ€™s authentication status, sets important HTTP headers (such as CORS) and applies various filters that enable developers to modify request processing.</p>



<p>A new <code>WP_REST_Request</code> object is created which holds all relevant details about the incoming request, such as HTTP method, query parameters, request body, headers, file uploads, etc.</p>



<p>The <code>check_authentication()</code> method ensures that the request is coming from a valid, authenticated source. This is where custom authentication mechanisms (like JWT tokens or API keys) can be applied. If authentication fails, the request is rejected with an appropriate error message.</p>



<p>Finally, the request is dispatched using the <code>dispatch()</code> method. This method matches the incoming request to one of the registered routes and executes the associated callback function. If the route doesnâ€™t exist, a 404 error is returned.</p>



<h2 class="wp-block-heading">The Response Flow</h2>



<p>After WordPress has successfully matched the request to a route and executed the relevant callback it needs to handle the response.</p>



<p>The callback function responsible for handling the route is executed. This function processes the request accesses any necessary data, performs database queries and prepares the data to be returned in the response.</p>



<p>The <code>respond_to_request()</code> method is used to construct the final response. Before this method, several filters are applied to allow developers to modify the request or return a custom response.</p>



<p>If the route has a defined <code>permission_callback</code>, this function is executed to ensure the current user has the appropriate permissions to access the route. If the callback returns <code>false</code> or a <code>WP_Error</code>, the request is rejected with a suitable error message.</p>



<p>WordPress ensures that the response data is properly formatted as a <code>WP_REST_Response</code> object. This function is crucial because it handles potential errors and ensures the response is in a valid JSON format with the correct HTTP status code.</p>



<p>WordPress then checks for any filters like <code>rest_post_dispatch</code>, which can be used to adjust the final <code>WP_REST_Response</code> object before itâ€™s sent to the client. You can modify the status code, add custom headers, or tweak the response data.</p>



<p>Headers such as <code>Content-Type</code>, <code>Cache-Control</code>, and any CORS-related headers are set. Also the appropriate HTTP status code is set.</p>



<p>The response data is then encoded into a JSON format using <code>wp_json_encode()</code>, and itâ€™s sent to the client as the final output.</p>



<p>Finally, WordPress calls <code>die()</code> to terminate the execution, ensuring no further code is run after the response is sent.</p>



<figure class="wp-block-image size-large"><img decoding="async" src="http://192.168.1.19:8080/wp-content/uploads/2025/03/image.png?w=360" alt="" class="wp-image-550" /></figure>



<h2 class="wp-block-heading">Conclusion</h2>



<p>Understanding the request-response flow in the WordPress REST API is essential for anyone looking to work with it at a deeper level. Whether building a plugin, developing custom functionality, having a solid grasp of this flow will make our development process smoother and more efficient.</p>



<p></p>
]]></content:encoded>
					
					<wfw:commentRss>/wordpress-rest-api-internals/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>WP-CLI Custom Commands</title>
		<link>/wp-cli-custom-commands/</link>
					<comments>/wp-cli-custom-commands/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Fri, 28 Feb 2025 15:04:02 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[plugin development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=524</guid>

					<description><![CDATA[As we have seen previously, WP-CLI offers a great way of interacting with WordPress through the command line. However, the true potential of WP-CLI is unlocked when we create custom commands for our specific needs. This blog explores how to create and utilize custom WP-CLI commands to streamline our workflow. Setting Up Our Custom Commands [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>As we have seen previously, WP-CLI offers a great way of interacting with WordPress through the command line. However, the true potential of WP-CLI is unlocked when we create custom commands for our specific needs. This blog explores how to create and utilize custom WP-CLI commands to streamline our workflow.</p>



<h3 class="wp-block-heading">Setting Up Our Custom Commands</h3>



<p>Before we can create custom commands, we need to make sure that the WordPress environment is set up fine. For WP-CLI to work we have define the <code>WP_CLI</code> constant and ensure its available.</p>



<pre class="wp-block-syntaxhighlighter-code">if (defined('WP_CLI') &amp;&amp; WP_CLI) {
    class Custom {
        // Our custom commands will go here
    }

    WP_CLI::add_command('example', 'Custom');
}</pre>



<h3 class="wp-block-heading">Defining Custom Commands</h3>



<p>Within our <code class="">Custom</code> class we can define multiple commands. Each command is a method within the class. </p>



<p>We can start with a simple command that greets a user.</p>



<pre class="wp-block-syntaxhighlighter-code">class Custom {
    /**
     * Prints a greeting.
     *
     * ## OPTIONS
     *
     * &lt;name&gt;
     * : The name of the person to greet.
     *
     * [--type=&lt;type&gt;]
     * : Whether or not to greet the person with success or error.
     * ---
     * default: success
     * options:
     *   - success
     *   - error
     * ---
     *
     * ## EXAMPLES
     *
     *     wp example hello Newman
     *
     * @when after_wp_load
     */
    function hello($args, $assoc_args) {
        list($name) = $args;

        // Print the message with type
        $type = $assoc_args['type'];
        WP_CLI::$type("Hello, $name!");
    }
}</pre>



<p>In this example, we have created a method called <code>hello</code>.<br>This command greets the user. It accepts a name as an argument and an optional <code>--type</code> argument to determine if the message should be displayed as a success or error.</p>



<h3 class="wp-block-heading">Fetching Blog Posts</h3>



<p>We can add another command to fetch blog posts. This command fetches the latest blog posts using WordPress&#8217;s REST API. It retrieves posts and formats them into a table to display the title and link.</p>



<pre class="wp-block-syntaxhighlighter-code">class Custom {
    // ...

    function blog($args, $assoc_args) {
        $response = wp_remote_get(rest_url('/wp/v2/posts'));
        $posts = json_decode(wp_remote_retrieve_body($response));

        $output = array();

        foreach ($posts as $post) {
            $output[] = array(
                'title' =&gt; $post-&gt;title-&gt;rendered,
                'link' =&gt; $post-&gt;link
            );
        }

        WP_CLI\utils\format_items('table', $output, array('title', 'link'));
    }
}</pre>



<h3 class="wp-block-heading">Exporting Data</h3>



<p>This command exports custom post types as a formatted output. It queries for all <code>my_event</code> post types retrieves relevant details like title, content, and link and displays them in a specified format.</p>



<pre class="wp-block-syntaxhighlighter-code">class Custom {
    // ...

    function export_event($args, $assoc_args) {
        $args = array(
            'post_type' =&gt; 'my_event',
            'posts_per_page' =&gt; -1,
        );
        $query = new WP_Query($args);

        if ($query-&gt;have_posts()) {
            $posts = array();
            while ($query-&gt;have_posts()) {
                $query-&gt;the_post();

                $posts[] = array(
                    'id' =&gt; get_the_ID(),
                    'title' =&gt; get_the_title(),
                    'content' =&gt; get_the_content(),
                    'link' =&gt; get_the_permalink(),
                );
            }

            WP_CLI\utils\format_items($assoc_args['format'], $posts, array('id', 'title', 'content', 'link'));
        }
    }
}</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>Custom WP-CLI commands offer a powerful way to extend the functionality of WP-CLI. By creating custom commands we can streamline our workflow, automate repetitive tasks, and enhance our productivity. Whether it&#8217;s greeting users, fetching blog posts, or exporting custom post types, the possibilities with custom commands are endless.</p>
]]></content:encoded>
					
					<wfw:commentRss>/wp-cli-custom-commands/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Working with the WP_Rest_Controller Class</title>
		<link>/working-with-the-wp_rest_controller-class/</link>
					<comments>/working-with-the-wp_rest_controller-class/#respond</comments>
		
		<dc:creator><![CDATA[lakshyajeet]]></dc:creator>
		<pubDate>Thu, 27 Feb 2025 14:41:53 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[plugin development]]></category>
		<category><![CDATA[seo]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[wp]]></category>
		<guid isPermaLink="false">https://lakshyajeet999.wordpress.com/?p=507</guid>

					<description><![CDATA[As we have seen previosly the REST API is an essential tool for creating dynamic and interactive web applications using WordPress. The WP_REST_Controller class is a fundamental part of this API, providing a structured way to handle RESTful routes and endpoints. What is WP_REST_Controller? The WP_REST_Controller class is an abstract class which provides basic structure [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>As we have seen previosly the REST API is an essential tool for creating dynamic and interactive web applications using WordPress. The <code class="">WP_REST_Controller</code> class is a fundamental part of this API, providing a structured way to handle RESTful routes and endpoints.</p>



<h2 class="wp-block-heading">What is <code>WP_REST_Controller</code>?</h2>



<p>The <code class="">WP_REST_Controller</code> class is an abstract class which provides basic structure for creating REST API endpoints. It includes methods for registering and handling requests and responses. By extending this class we can create custom endpoints.</p>



<h2 class="wp-block-heading">Extending <code>WP_REST_Controller</code></h2>



<p>First we need to create a new class that will inherit <code>WP_REST_Controller</code> class, this class will define routes and handle the requests at custom end points.</p>



<h3 class="wp-block-heading">Defining Custom controller class</h3>



<pre class="wp-block-syntaxhighlighter-code">&lt;?php
use WP_REST_Controller;
use WP_REST_Request;
use WP_REST_Response;
use WP_REST_Server;

class Custom_REST_Controller extends WP_REST_Controller {
    public function __construct() {
        $this-&gt;namespace = 'namespace/v1';
        $this-&gt;rest_base = 'our-endpoint';

        add_action( 'rest_api_init', array( $this, 'register_routes' ) );
    }

    public function register_routes() {
        register_rest_route(
            $this-&gt;namespace,
            '/' . $this-&gt;rest_base,
            array(
                array(
                    'methods'             =&gt; WP_REST_Server::READABLE,
                    'callback'            =&gt; array( $this, 'get_items' ),
                    'permission_callback' =&gt; array( $this, 'get_items_permissions_check' ),
                    'args'                =&gt; $this-&gt;get_collection_params(),
                ),
                array(
                    'methods'             =&gt; WP_REST_Server::CREATABLE,
                    'callback'            =&gt; array( $this, 'create_item' ),
                    'permission_callback' =&gt; array( $this, 'create_item_permissions_check' ),
                    'args'                =&gt; $this-&gt;get_endpoint_args_for_item_schema( WP_REST_Server::CREATABLE ),
                ),
                'schema' =&gt; array( $this, 'get_public_item_schema' ),
            )
        );

        register_rest_route(
            $this-&gt;namespace,
            '/' . $this-&gt;rest_base . '/(?P&lt;id&gt;[\d]+)',
            array(
                'args'   =&gt; array(
                    'id' =&gt; array(
                        'type' =&gt; 'integer',
                    ),
                ),
                array(
                    'methods'             =&gt; WP_REST_Server::READABLE,
                    'callback'            =&gt; array( $this, 'get_item' ),
                    'permission_callback' =&gt; array( $this, 'get_item_permissions_check' ),
                    'args'                =&gt; array(
                        'context' =&gt; $this-&gt;get_context_param( array( 'default' =&gt; 'view' ) ),
                    ),
                ),
                array(
                    'methods'             =&gt; WP_REST_Server::EDITABLE,
                    'callback'            =&gt; array( $this, 'update_item' ),
                    'permission_callback' =&gt; array( $this, 'update_item_permissions_check' ),
                    'args'                =&gt; $this-&gt;get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),
                ),
                array(
                    'methods'             =&gt; WP_REST_Server::DELETABLE,
                    'callback'            =&gt; array( $this, 'delete_item' ),
                    'permission_callback' =&gt; array( $this, 'delete_item_permissions_check' ),
                ),
                'schema' =&gt; array( $this, 'get_public_item_schema' ),
            )
        );
    }

    public function get_items( WP_REST_Request $request ) {
        // Implement logic to retrieve items
    }

    public function get_item( WP_REST_Request $request ) {
        // Implement logic to retrieve a single item
    }

    public function create_item( WP_REST_Request $request ) {
        // Implement logic to create a new item
    }

    public function update_item( WP_REST_Request $request ) {
        // Implement logic to update an item
    }

    public function delete_item( WP_REST_Request $request ) {
        // Implement logic to delete an item
    }

    public function get_items_permissions_check( WP_REST_Request $request ) {
        // Implement permission check logic
    }

    public function get_item_permissions_check( WP_REST_Request $request ) {
        // Implement permission check logic
    }

    public function create_item_permissions_check( WP_REST_Request $request ) {
        // Implement permission check logic
    }

    public function update_item_permissions_check( WP_REST_Request $request ) {
        // Implement permission check logic
    }

    public function delete_item_permissions_check( WP_REST_Request $request ) {
        // Implement permission check logic
    }

    public function prepare_item_for_response( $item, WP_REST_Request $request ) {
        // Implement logic to prepare the item for the response
    }

    public function get_collection_params() {
        // Implement logic to get the collection parameters
    }
}</pre>



<p>We need to register routes this will be done by implementing the <code>register_routes()</code> function. This function will hold all the routes and their parameters.</p>



<h3 class="wp-block-heading">Implementing the methods</h3>



<p>After defining the structure of our routes we need to make sure all our callbacks are defined. </p>



<p>Egâ€” Sample function definition of <code>get_items</code> and <code>create_item</code>.</p>



<pre class="wp-block-syntaxhighlighter-code">public function get_items( WP_REST_Request $request ) {
    $args = array(
        'post_type'      =&gt; 'custom-post-type',
        'posts_per_page' =&gt; $request['per_page'],
        'paged'          =&gt; $request['page'],
        'orderby'        =&gt; $request['orderby'],
        'order'          =&gt; $request['order'],
    );

    if ( ! empty( $request['search'] ) ) {
        $args['s'] = $request['search'];
    }

    $query = new WP_Query( $args );
    $posts = array();

    if ( $query-&gt;have_posts() ) {
        while ( $query-&gt;have_posts() ) {
            $query-&gt;the_post();
            $data    = $this-&gt;prepare_item_for_response( get_post(), $request );
            $posts[] = $this-&gt;prepare_response_for_collection( $data );
        }
        wp_reset_postdata();
    }

    $response = rest_ensure_response( $posts );
    return $response;
}</pre>



<pre class="wp-block-syntaxhighlighter-code">public function create_item( $request ) {
    $title = sanitize_text_field( $request['title'] );
    $content = wp_kses_post( $request['content'] );
    $status = sanitize_text_field( $request['status'] );

    $new_post = array(
        'post_type' =&gt; 'custom-post-type',
        'post_title' =&gt; $title,
        'post_content' =&gt; $content,
        'post_status' =&gt; $status,
        'post_author' =&gt; get_current_user_id(),
    );

    $post_id = wp_insert_post( $new_post );

    if ( is_wp_error( $post_id ) ) {
        return $post_id;
    }

    return rest_ensure_response( $this-&gt;prepare_item_for_response( get_post( $post_id ), $request ) );
}</pre>



<h3 class="wp-block-heading">Implementing Permission callbacks</h3>



<p>The <code>permission_callback</code> is used to ensure the correct permissions are in place before any data is retrieved or modified on every request.</p>



<pre class="wp-block-syntaxhighlighter-code">public function create_item_permissions_check( $request ) {
    return is_user_logged_in() &amp;&amp; current_user_can( 'publish_posts' );
}</pre>



<h3 class="wp-block-heading">Preparing the Response</h3>



<pre class="wp-block-syntaxhighlighter-code">public function prepare_item_for_response( $post, $request ) {
    return array(
        'id' =&gt; $post-&gt;ID,
        'title' =&gt; $post-&gt;post_title,
        'content' =&gt; $post-&gt;post_content,
    );
}</pre>



<h3 class="wp-block-heading">Registering the Routes</h3>



<p>The last thing we need to do before our routes are available is to register them using the <code>rest_api_init</code> hook.</p>



<pre class="wp-block-syntaxhighlighter-code">add_action( 'rest_api_init', function() {
    $controller = new Custom_REST_Controller();
    $controller-&gt;register_routes();
} );</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>The <code>WP_Rest_Controller</code> class provides a solid foundation for building custom REST API endpoints in WordPress. By extending this class, we can define custom routes and handle CRUD operations.</p>
]]></content:encoded>
					
					<wfw:commentRss>/working-with-the-wp_rest_controller-class/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
